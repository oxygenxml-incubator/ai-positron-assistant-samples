[
    {
        "id": "com.oxygenxml.ai.positron.action.dita.analyzeTopic",
        "title": "Analyze topic",
        "categoryId": "Analyze",
        "type": "show-response",
        "framework": "text/xml",
        "input-type": "markup",
        "description": "Analyze DITA topic",
        "context": "${contextInfo} \nYour task is to analyze a DITA topic and determine if it follows the main characteristics of DITA topics and propose and execute updates on that topic to make it adhere to DITA philosophy. These updates can modify that topic, generate additional topics, update the DITA map to contain references to the newly created topic files, if any.\n\nInformation about DITA topic types\n============\n\nTopics are small, self-contained units of information designed for modularity, reuse, and consistency. \nHere it is a list of common DITA topic types and their meanings:\n\n   - concept: explains or defines an idea, provides context, or introduces background information.\n   - task: provides step-by-step instructions so a user can accomplish a specific procedure or goal.\n   - reference: provides quick-look data, parameter lists, specifications, or factual details that users may refer to frequently.\n   - troubleshooting: guides users through identifying, diagnosing, and solving a specific problem.\n   - glossary entry defines a sense of a glossary term,  glossary entries for different term senses can be reused independently of one another.\n   - glossary group groups multiple gossary entris in the same document.\n   - topic: base DITA topic, if a more specific topic type cannot be determined\n\n\nGeneral Instructions\n===========\n\n * In case there are nested topics in the DITA topic you analyze, apply the checks for each one.\n * Use the title element to generate appropriate file names. \n * Once you got the confirmation to proceed do not ask for further confirmations.\n * When inserting related links use a tempalate such as:\n```\n<related-links>\n    <link href=\"[targetTopicFile.dita]\"><linktext>[Target topic title]</linktext></link>\n</related-links>\n```\n\nWhat  you need  to do\n========\n\nCheck if the topic covers a single subject or answer to a specific question\n\n    1. If the topic covers a single subject or answer to a specific question \n        a. Write which subject or question you identified that the topic covers\n        b. The existing topic type is determined by the XML element that encodes that topic \n        c. Analyze the content and see what topic type will be appropriate for that content\n        d. write the determined topic type versus the appropriate topic type. \n        d. Compare existing type topic to the appropriate topic type, if they are different convert to the appropriate topic type. \n\n    2. If the the topic covers multiple subjects/answers more questions\n        a. Write a list with all the subjects that are covered/all the questions that it answers \n        b. Split the topic content into parts, making sure you do not miss any content and that each part covers a single subject, and determine the appropriate topic type for each part, and identify which part serves as information that should remain in the existing topic (the existing topic must keep its file name unchanged, do not rename it)\n        c. Write a summary and explain the plan that you are about to execute, include the topic titles and file names.\n        d. Before applying the changes from your plan ask the user to confirm that you should proceed, or if the user wants to make any updates to the plan, the question should be formulated such that andwering yes will be a clear indication that the user wants to proceed with the plan.\n        e. If the user agrees to proceed continue to next steps, otherwise take into account the user feedback and update the plan and ask again for confirmation.\n        f. Perform the conversion of each part to the appropriate topic type that was determined in the plan.\n\n    3. You will process now each of the generated content obtained after the conversion, as indicated furter, and write a summary of the changes you  are about to make:\n        a. update the topic to add <related-links> with links between the topic and  topics with related content, if there are no related links, do not add an empty related-links element - write what related links you will add to each topic content\n        b. edit the metadata to include relevant metadata from the original topic and remove metadata irrelevant to the topic content..\n            \n    4. Save the generated and processed content to the newly created topics and to the existing topic.\n     \n    5. If there were new topics generated, update the map to add references to the newly created topic files.\n\nIf there is content that is not present in the converted output so add it inside an XML comment, such as\n```\n<!-- content not converted -->\n```\n\n\nTool information\n========\n\nTo convert content to DITA task use the \"invoke_ai_action\" tool with the action \"com.oxygenxml.ai.positron.action.dita.formatTask\".\nTo convert content to DITA concept use the \"invoke_ai_action\" tool with the action \"com.oxygenxml.ai.positron.action.dita.formatConcept\".\nTo convert content to DITA reference use the \"invoke_ai_action\" tool with the action \"com.oxygenxml.ai.positron.action.dita.formatReference\".\nTo convert content to DITA troubleshooting use the \"invoke_ai_action\" tool with the action \"com.oxygenxml.ai.positron.action.dita.formatTroubleshooting\".\nTo convert content to DITA glossentry or glssgroup use the \"invoke_ai_action\" tool with the action \"com.oxygenxml.ai.positron.action.dita.formatGlossay\".\nTo convert to any other topic type, such as generic topic, do it yourself.\nUse the \"save_document\" function to save a file.\n",
        "expand-params": [
            {
                "name": "contextInfo",
                "value": "${contextInfo}"
            }
        ],
        "parameters": {
            "temperature": 0,
            "function_refs": [
                {"ref": "save_document"},
                {"ref": "get_current_editor_file_location"},
                {"ref": "validate_document_content"},
                {"ref": "add_to_toc"},
                {"ref": "get_content_for_document_url"},
                {"ref": "get_topic_context_in_toc"},
                {"ref": "resolve_dita_key_or_content_reference"},
                {"ref": "get_corresponding_dita_keyrefs"},
                {"ref": "get_related_content_from_project"},
                {"ref": "invoke_ai_action"}
            ]
        }
    },
    {
        "id": "com.oxygenxml.ai.positron.action.dita.convertToDITA",
        "title": "Convert to DITA",
        "categoryId": "Analyze",
        "type": "show-response",
        "framework": "text/markdown",
        "input-type": "markup",
        "description": "Convert content to DITA topics",
        "context": "${contextInfo} \nYour task is use tools to convert a given content to DITA without loosing any information and save the converted topics. Analyze the given content and decide how to split it into topics and what type of topic to use for each. You will generate also a new DITA map to contain references to the newly created topic files.\n\nInformation about DITA topic types\n============\n\nHere it is a list of common DITA topic types and their meanings:\n\n   - concept: explains or defines an idea, provides context, or introduces background information.\n   - task: provides step-by-step instructions so a user can accomplish a specific procedure or goal.\n   - reference: provides quick-look data, parameter lists, specifications, or factual details that users may refer to frequently.\n   - troubleshooting: guides users through identifying, diagnosing, and solving a specific problem.\n   - glossary entry defines a sense of a glossary term,  glossary entries for different term senses can be reused independently of one another.\n   - glossary group groups multiple gossary entris in the same document.\n   - topic: base DITA topic, if a more specific topic type cannot be determined.\n\nTopics are small, self-contained units of information designed for modularity, reuse, and consistency. \n\nWhat  you need  to do\n========\n\n1. Check all the provided content and identify the subjects that are covered/the questions that it answers\n2. If the content  covers a single subject:\n    a. Analyze the content and see what topic type will be appropriate for that content\n    b. Convert to the appropriate topic type and save the generated topic file. \n3. If the topic covers multiple subjects\n    a. Split the content into parts, making sure you do not miss any content so that each part covers a single subject\n    b. determine the the appropriate topic type for each part.\n    c. Write down a summary and explain the plan that you are about to execute.\n    d. Before applying the changes from your plan ask the user to specify if you should proceed or if the user wants to make any updates to the plan.\n    e. If the user agrees to proceed continue to next steps, otherwise take into account the user feedback and update the plan and ask again form confirmation.\n    f. Use available tools to perform the conversion of each part to the appropriate topic type that was determined in the plan and save the newly created topics.\n    c. Generate a DITA map that contains references to all the new topics and save it, using the following template:\n        ```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE map PUBLIC \"-//OASIS//DTD DITA Map//EN\" \"map.dtd\">\n<map>\n    <title>[the map title]</title>\n    [topicref  elements poiting to the new or updated topics]\n</map>\n        ```\n\nUse the title element to generate appropriate file names. \nOnce you got the confirmation to proceed, save the generated content on any file without further confirmations.\n\nTool information\n========\n\nTo convert content to DITA task use the \"invoke_ai_action\" tool with the action \"com.oxygenxml.ai.positron.action.dita.formatTask\".\nTo convert content to DITA concept use the \"invoke_ai_action\" tool with the action \"com.oxygenxml.ai.positron.action.dita.formatConcept\".\nTo convert content to DITA reference use the \"invoke_ai_action\" tool with the action \"com.oxygenxml.ai.positron.action.dita.formatReference\".\nTo convert content to DITA troubleshooting use the \"invoke_ai_action\" tool with the action \"com.oxygenxml.ai.positron.action.dita.formatTroubleshooting\".\nTo convert content to DITA glossentry or glssgroup use the \"invoke_ai_action\" tool with the action \"com.oxygenxml.ai.positron.action.dita.formatGlossay\".\nTo convert to any other topic type, such as generic topic, do it yourself.\nUse the \"save_document\" function to save a file.\n\nContent to be converted to task follows\n============================\n",
        "expand-params": [
            {
                "name": "contextInfo",
                "value": "${contextInfo}"
            }
        ],
        "parameters": {
            "temperature": 0,
            "function_refs": [
                {"ref": "save_document"},
                {"ref": "get_current_editor_file_location"},
                {"ref": "validate_document_content"},
                {"ref": "add_to_toc"},
                {"ref": "get_content_for_document_url"},
                {"ref": "get_topic_context_in_toc"},
                {"ref": "resolve_dita_key_or_content_reference"},
                {"ref": "get_corresponding_dita_keyrefs"},
                {"ref": "get_related_content_from_project"},
                {"ref": "invoke_ai_action"}
            ]
        }
    },
    {
        "id": "com.oxygenxml.ai.positron.action.dita.convertToDITA2",
        "title": "Convert to DITA 2",
        "categoryId": "Analyze",
        "type": "show-response",
        "framework": "text/markdown",
        "input-type": "markup",
        "description": "Convert content to DITA topics 2",
        "context": "${contextInfo} \n\n1. Split the content into parts, each part containing the content for a DITA topic (topics are small, self-contained units of information designed for modularity, reuse, and consistency) and identify the topic type and a title for each part:\n<content>\n<part title=\"title\" type=\"topic type\" filename=\"filename\">\n  part content\n</part>\n ...\n</content>\n\n2. After you generate this structure\n    a. take each part and apply the corresponding conversion as specified by the type attribute then save the result as specified by the filename attribute.\n    b. generate a DITA map with references to the saved topics and save it\n\n\nInformation about DITA topic types\n============\n\nHere it is a list of common DITA topic types and their meanings:\n\n   - concept: explains or defines an idea, provides context, or introduces background information.\n   - task: provides step-by-step instructions so a user can accomplish a specific procedure or goal.\n   - reference: provides quick-look data, parameter lists, specifications, or factual details that users may refer to frequently.\n   - troubleshooting: guides users through identifying, diagnosing, and solving a specific problem.\n   - glossary entry defines a sense of a glossary term,  glossary entries for different term senses can be reused independently of one another.\n   - glossary group groups multiple gossary entris in the same document.\n   - topic: base DITA topic, if a more specific topic type cannot be determined.\n\n\nUse the title element to generate appropriate file names. \n\nTool information\n========\n\nTo convert content to DITA task use the \"invoke_ai_action\" tool with the action \"com.oxygenxml.ai.positron.action.dita.formatTask\".\nTo convert content to DITA concept use the \"invoke_ai_action\" tool with the action \"com.oxygenxml.ai.positron.action.dita.formatConcept\".\nTo convert content to DITA reference use the \"invoke_ai_action\" tool with the action \"com.oxygenxml.ai.positron.action.dita.formatReference\".\nTo convert content to DITA troubleshooting use the \"invoke_ai_action\" tool with the action \"com.oxygenxml.ai.positron.action.dita.formatTroubleshooting\".\nTo convert content to DITA glossentry or glssgroup use the \"invoke_ai_action\" tool with the action \"com.oxygenxml.ai.positron.action.dita.formatGlossay\".\nTo convert to any other topic type, such as generic topic, do it yourself.\nUse the \"save_document\" function to save a file.\n\n\nContent follows\n============\n",
        "expand-params": [
            {
                "name": "contextInfo",
                "value": "${contextInfo}"
            }
        ],
        "parameters": {
            "temperature": 0,
            "function_refs": [
                {"ref": "save_document"},
                {"ref": "get_current_editor_file_location"},
                {"ref": "validate_document_content"},
                {"ref": "add_to_toc"},
                {"ref": "get_content_for_document_url"},
                {"ref": "get_topic_context_in_toc"},
                {"ref": "resolve_dita_key_or_content_reference"},
                {"ref": "get_corresponding_dita_keyrefs"},
                {"ref": "get_related_content_from_project"},
                {"ref": "invoke_ai_action"}
            ]
        }
    },
    {
        "id": "com.oxygenxml.ai.positron.action.dita.formatTask",
        "title": "Format as task",
        "categoryId": "Analyze",
        "type": "replace-selection-with-fragment",
        "framework": "text/xml",
        "input-type": "markup",
        "description": "Format as DITA task",
        "expand-params": [
            {
                "name": "contextInfo",
                "value": "${contextInfo}"
            }
        ],
        "context": "${contextInfo} \nYour task is to convert to a DITA task all the content of a document which is encoded in a different format or it is provided as plain text or Markdown. \n\nIf the content contains information about multiple tasks then split the initial content to reflect the content for each task and then generate multiple task topics inside a dita composite document.\n\nStart the response topic with the XML declaration and the task or dita DOCTYPE declaration:\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE task PUBLIC \"-//OASIS//DTD DITA General Task//EN\" \"generalTask.dtd\">\n```\nor \n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE dita PUBLIC \"-//OASIS//DTD DITA Composite//EN\" \"ditabase.dtd\">\n```\n\nGenerate id attribute for the task root element and for additional tasks if any.\nPreserve metadata information such as: altenative titles, navtitles, prolog information.\nPreserve profiling information defined by profiling attributes such as product, audience, platform, deliveryTarget, props, otherprops.\nInclude content references, elements that contain conref or conkeyref or keyref attributes, you may use the resolve_dita_key_or_content_reference function if you want to find the actual content they exand to.\n\nBelow you find information about DITA tasks.\n\nInformation about DITA tasks\n=====================\nThe <task> element is the top-level element for a task topic. Tasks are the main building blocks for task-oriented user assistance. They generally provide step-by-step instructions that will enable a user to perform a task. A task answers the question of \"how to?\" by telling the user precisely what to do and the order in which to do it. Tasks have the same high-level structure as other topics, with a title, short description and body.\nThe <taskbody> element is the main body-level element inside a task topic. A task body is designed to contain information specific to completing a task, such as prerequisites, contextual information, and steps.\nThe <context> element provides background information for a task. This information helps the user understand what the purpose of the task is and what they will gain by completing the task. This section should be brief and does not replace or recreate a concept topic on the same subject, although the context section might include some conceptual information.\n<context> contains [general DITA block elements].\nThe <prereq> element of a task contains prerequisites that the user needs to know or do before starting the current task. \nThe <steps> element provides the main content of a task topic. The task is described as a series of steps that the user must follow to accomplish the task. At least one <step> element is required inside the <steps> element.\nLike the <steps> element, the <steps-unordered> element provides the main content of a task topic, but particularly for cases in which the order of steps might vary from one situation to another. At least one <step> element is required inside the <steps-unordered> element.\nThe <steps-informal> element allows authors to describe procedural task information without placing each step in an individual container element, which is a requirement of the related <steps> and <steps-unordered> elements. For example, <steps-informal> might contain a paragraph that describes more than one step in a single sentence, or it might contain sentences that mix steps together with information about the steps.\nThe <result> element describes the expected outcome for the task as a whole. \nThe <tasktroubleshooting> element provides information designed to help users remedy the situation when a task does not complete as expected. In particular, this element can be used to explain how users can recover when the results of a task do not match those listed in the <result> element. The troubleshooting remedy typically contains one or more actions for solving a problem. For complex remedies, link to another task.\nThe <example> element is a section that contains examples that illustrate or support the current topic. Use <example> to contain both sample code (or similar artifacts) and the discussion that illustrates the sample. For example, a DITA topic about programming code could use the <example> element to contain both the sample code and the text that describes the code. Similarly, a sample that included preformatted text might use the <pre> element along with a paragraph or list to elaborate upon sections of that text.\nThe <postreq> element describes steps or tasks that the user should do after the successful completion of the current task. It is often supported by links to the next task or tasks in the <related-links> section.\nThe <stepsection> element provides expository text before a <step> element. Although the element is specialized from <li> and has the same content model as a list item, it is not intended to represent a step in a task.\nThe <step> element represents an action that a user must follow to accomplish a task. Each step in a task must contain a command <cmd> element which describes the particular action the user must do to accomplish the overall task. It is possible to place a <note> element before the command in order to notify the user of dangers or other important information about the step. The <step> element can also contain additional optional information about the step, such as sub-steps, a list of choices, or result information.\nThe <substeps> element allows you to break a step down into a series of separate actions, and should be used only if necessary. Try to describe the steps of a task in a single level of steps. If you need to use more than one level of <substep> nesting, you should probably rewrite the task to simplify it.\nA <substep> does NOT allow lists of choices or sub-steps within it, in order to prevent unlimited nesting of steps, so make sure you do not add <choices> or <substeps> inside it.\nThe <cmd> element specifies a command, which is a required element inside the <step> or <substep> element. It provides the active voice instruction to the user for completing the step, and should not be more than one sentence. If the step or substep needs additional explanation, place the explanation in an <info> element following the <cmd>. \nThe <choices> element contains a list of <choice> elements. It is used when the user will need to choose one of several actions while performing the steps of a task. \nEach <choice> element describes one way that the user could perform the current step, it does not contain <cmd>.\nThe <choicetable> element contains a series of optional choices available within a step of a task.\nThe <choptionhd> element provides a specific label for the list of options from which a user chooses in order to accomplish a step. \nThe <chdeschd> element provides a specific label for the list of descriptions of options from which a user chooses in order to accomplish a step. \nThe <choption> element describes an option in a choice table that a user could choose to accomplish a step of a task. In a user interface, for example, this might be the name of radio button.\nThe <chdesc> element is a description of an option from a choice table that a user chooses while performing a step to accomplish a task. It explains why the user would choose that option and might explain the result of the choice when it is not immediately obvious.\nThe <info> element occurs inside a <step> or <substep> element to provide additional information about that step or substep.\nThe <itemgroup> element can be used to sub-divide or organize elements that occur inside a list item, definition, or parameter definition.\nThe <stepxmp> element is used to illustrate a step of a task. The step example can be a couple of words, or an entire paragraph.\nThe <tutorialinfo> element contains additional information that is useful when the task is part of a tutorial.\nThe <stepresult> element provides information on the expected outcome of a step. If a user interface is being documented, the outcome could describe a dialog box opening or the appearance of a progress indicator. Step results are useful to assure a user that they are on track, but should not be used for every step as this quickly becomes tedious.\nThe <steptroubleshooting> element provides information that is designed to help remedy the situation when a step does not complete as expected. In particular, this element can be used to explain how users can recover when the results of a step do not match those listed in the <stepresult> element.\n\nTips\n=======\n* Do not generate a <note> or <codeblock> after </info>, generate them inside that <info> element, before the </info> closing tag.\n* <info> should not be placed inside a <choice> parent element.  \n* Preserve codeblock from the original content exactly as it is, including all whitespaces and indenting.\n* Do not place <codeblock> directly inside a step, wrap it in <info>.\n* Do not place <note> directly inside a step, if the note is after <cmd>, wrap it in <info>.\n* Do not loose content references (elements with conref, keyref or conkeyref attribute) such as <note conref=\"…\"/>.\n* Do not replace content references (elements with conref, keyref or conkeyref attribute) with the expanded content.\n* There is only one <steps> or <steps-informal> or <steps-unordered> allowed in a task body.\n* Do not nest <substeps>.\n* The <stepresult> element has parent elements <step> and <substep>, do not generate it inside <info>, generate it after the </info> closing tag.\n* The <codeph> element represents a snippet of code within the main flow of text.\n* Make sure you close an element with the same tag name as its start tag.\n\nContent model information \n====================\n\nIn the models below \"?\" means optional, \",\" delimits sequence items, \"*\" means zero or more, \"|\" represents choice and \"(\" and \")\" are used for grouping. Always make sure that these content models are respected when you generate content.\n\n<task> contains: \n<title>, <titlealts>?, (<abstract> | <shortdesc>)?, <prolog>?, <taskbody>?, <related-links>?, <task>*\n\n<taskbody> contains: \n(<context> | <prereq> | <section>)*, (<steps> | <steps-informal> | <steps-unordered>)?, <result>?, <tasktroubleshooting>?, <example>*, <postreq>*\n\n<steps> or <steps-unordered> contain:\n(<data> | <data-about> | <sort-as>)*, <stepsection>?, (<step>)+\n\n<step> contains:\n(<hazardstatement> | <note>)*, <cmd>, (<choices> | <choicetable> | <info> | <itemgroup> | <stepxmp> | <substeps> | <tutorialinfo>)*, <stepresult>?, <steptroubleshooting>?\n\n<substeps> contains:\n(<data> | <data-about> | <sort-as>)*, <substep>+\n\n<substep> contains:\n(<hazardstatement> | <note>)*, <cmd>, (<info> | <itemgroup> | <stepxmp> | <tutorialinfo>)*, <stepresult>?\n\n<choices> contains:\n(<data> | <data-about> | <sort-as>)*, <choice>+\n\nchoicetable> contains:\n<chhead>?, <chrow>+\n\n<chhead> contains:\n<choptionhd>, <chdeschd>\n\n<chrow> contains\n<choption>, <chdesc>\n\n<prereq> or <steps-informal> or <result> or <tasktroubleshooting> or <postreq> or <stepsection> or <choice> or <choptionhd> or <chdeschd> or <choption> or <chdesc> or <info> or <cmd> or <itemgroup> or <stepxmp> or <tutorialinfo> or <stepresult> or <steptroubleshooting> contain:\n(text data | <abbreviated-form> | <apiname> | <b> | <boolean> | <cite> | <cmdname> | <codeblock> | <codeph> | <data> | <data-about> | <div> | <dl> | <draft-comment> | <equation-block> | <equation-figure> | <equation-inline> | <fig> | <filepath> | <fn> | <foreign> | <hazardstatement> | <i> | <image> | <imagemap> | <indexterm> | <indextermref> | <keyword> | <line-through> | <lines> | <lq> | <markupname> | <mathml> | <menucascade> | <msgblock> | <msgnum> | <msgph> | <note> | <numcharref> | <object> | <ol> | <option> | <overline> | <p> | <parameterentity> | <parml> | <parmname> | <ph> | <pre> | <q> | <required-cleanup> | <screen> | <sectiondiv> | <simpletable> | <sl> | <sort-as> | <state> | <sub> | <sup> | <svg-container> | <synph> | <syntaxdiagram> | <systemoutput> | <table> | <term> | <text> | <textentity> | <tm> | <tt> | <u> | <uicontrol> | <ul> | <unknown> | <userinput> | <varname> | <wintitle> | <xmlatt> | <xmlelement> | <xmlnsname> | <xmlpi> | <xref>)*\n\n<example> contains:\n(text data | <b> | <boolean> | <cite> | <data> | <data-about> | <div> | <dl> | <draft-comment> | <fig> | <fn> | <foreign> | <hazardstatement> | <i> | <image> | <imagemap> | <indexterm> | <indextermref> | <keyword> | <line-through> | <lines> | <lq> | <note> | <object> | <ol> | <overline> | <p> | <ph> | <pre> | <q> | <required-cleanup> | <simpletable> | <sl> | <sort-as> | <state> | <sub> | <sup> | <table> | <term> | <text> | <title> | <tm> | <tt> | <u> | <ul> | <unknown> | <xref>)*\n\nContent to be converted to task follows\n============================\n",
        "parameters": {
            "temperature": 0,
            "function_refs": [
                {"ref": "validate_document_content"},
                {"ref": "resolve_dita_key_or_content_reference"},
                {"ref": "get_corresponding_dita_keyrefs"},
                {"ref": "get_related_content_from_project"}
            ]
        }
    },
    {
        "id": "com.oxygenxml.ai.positron.action.dita.formatConcept",
        "title": "Format as concept",
        "categoryId": "Analyze",
        "type": "replace-selection-with-fragment",
        "framework": "text/xml",
        "input-type": "markup",
        "description": "Format as DITA concept",
        "expand-params": [
            {
                "name": "contextInfo",
                "value": "${contextInfo}"
            }
        ],
        "context": "${contextInfo} \nYour will generate a DITA concept from the all content of given document that contains conceptual information but is encoded in a different format or it is provided as plain text or Markdown. \nIf the content contains consistent information about multiple concepts then split the initial content to reflect the content for each concept and then generate multiple concept topics inside a dita composite document.\n\nStart the response with the XML declaration and the concept or dita DOCTYPE declaration:\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE concept PUBLIC \"-//OASIS//DTD DITA Concept//EN\" \"concept.dtd\">\n```\nor \n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE dita PUBLIC \"-//OASIS//DTD DITA Composite//EN\" \"ditabase.dtd\">\n```\n\nGenerate id attribute for the concept root element and for additional concepts if any.\nPreserve metadata information such as: altenative titles, navtitles, prolog information.\nPreserve profiling information defined by profiling attributes such as product, audience, platform, deliveryTarget, props, otherprops.\nInclude content references, elements that contain conref or conkeyref or keyref attributes, you may use the resolve_dita_key_or_content_reference function if you want to find the actual content they exand to.\n\nBelow you find information about DITA concepts.\n\nInformation about DITA concepts\n========================\n\nThe <concept> element is the top-level element for a topic that answers the question \"what is?\" Concepts provide background information that users must know before they can successfully work with a product or interface. Often, a concept is an extended definition of a major abstraction such as a process or function.\n\nThe <conbody> element is the main body-level element for a concept.\n<conbody> allows paragraphs, lists, and other elements as well as sections and examples. However, <conbody> has a restriction that a <section> or an <example> can be followed only by other sections, examples, or <conbodydiv> elements that group sections and examples.\n\nThe <conbodydiv> element provides an informal container for content that might be grouped within a concept. There are no additional semantics attached to the <conbodydiv> element; it is purely a grouping element provided to help organize content.\nThe <conbodydiv> element, which allows groupings of sections and examples, keeps the same restriction in place; once used, only sections, examples, or other <conbodydiv> groups are allowed.\n\nTips\n=======\n* Preserve codeblock from the original content exactly as it is, including all whitespaces and indenting.\n* Do not loose content references (elements with conref, keyref or conkeyref attribute) such as <note conref=\"…\"/>.\n* Do not replace content references (elements with conref, keyref or conkeyref attribute) with the expanded content.\n* The <codeph> element represents a snippet of code within the main flow of text.\n* Make sure you close an element with the same tag name as its start tag.\n\nContent model information \n====================\n\nIn the models below \"?\" means optional, \",\" delimits sequence items, \"*\" means zero or more, \"|\" represents choice and \"(\" and \")\" are used for grouping. Always make sure that these content models are respected when you generate content.\n\n<concept> contains: \n<title>, <titlealts>?, (<abstract> | <shortdesc>)?, <prolog>?, <conbody>?, <related-links>?, <concept>*\n\nconbody contains:\n(<codeblock> | <data> | <data-about> | <div> | <dl> | <draft-comment> | <equation-block> | <equation-figure> | <fig> | <foreign> | <hazardstatement> | <image> | <imagemap> | <lines> | <lq> | <mathml> | <msgblock> | <note> | <object> | <ol> | <p> | <parml> | <pre> | <required-cleanup> | <screen> | <simpletable> | <sl> | <sort-as> | <svg-container> | <syntaxdiagram> | <table> | <ul> | <unknown>)*, (<conbodydiv> | <example> | <section>)*\n\n<conbodydiv> contains:\n(<example> | <section>)*\n\n\nContent to be converted to concept follows\n============================",
        "parameters": {
            "temperature": 0,
            "function_refs": [
                {"ref": "validate_document_content"},
                {"ref": "resolve_dita_key_or_content_reference"},
                {"ref": "get_corresponding_dita_keyrefs"},
                {"ref": "get_related_content_from_project"}
            ]
        }
    },
    {
        "id": "com.oxygenxml.ai.positron.action.dita.formatReference",
        "title": "Format as reference",
        "categoryId": "Analyze",
        "type": "replace-selection-with-fragment",
        "framework": "text/xml",
        "input-type": "markup",
        "description": "Format as DITA reference",
        "expand-params": [
            {
                "name": "contextInfo",
                "value": "${contextInfo}"
            }
        ],
        "context": "${contextInfo} \nYour task is to generate a DITA reference topic from all the content of given document that contains reference information but is encoded in a different format or it is provided as plain text or Markdown. \n\nStart the response topic with the XML declaration and the reference DOCTYPE declaration:\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE reference PUBLIC \"-//OASIS//DTD DITA Reference//EN\" \"reference.dtd\">\n```\n\nGenerate id attribute for the reference root element and for additional references if any.\nPreserve metadata information such as: altenative titles, navtitles, prolog information.\nPreserve profiling information defined by profiling attributes such as product, audience, platform, deliveryTarget, props, otherprops.\nInclude content references, elements that contain conref or conkeyref or keyref attributes, you may use the resolve_dita_key_or_content_reference function if you want to find the actual content they exand to.\n\nBelow you find information about DITA reference topics.\n\nInformation about DITA reference topics\n========================\n\nReference topics represent a set of factual information. \n\nThe <reference> element defines a top-level container for a reference topic. Reference topics provide quick access to facts, but they do not contain a deeper explanation of related concepts or tasks.\n\nThe <refbody> element is a container for the main content of the reference topic, containing tables, property lists, syntax sections, sections and examples.\n\nThe <refbodydiv> element provides an informal container for content that might be grouped within a reference. There are no additional semantics attached to the <refbodydiv> element; it is purely a grouping element provided to help organize content. The <refbodydiv> element can nest itself.\n\nThe <refsyn> element is a special section inside a reference topic. The section often contains syntax or signature content (for example, the calling syntax for a command-line utility or an API signature). The <refsyn> contains a brief, possibly diagrammatic description of the subject's interface or high-level structure.\n\nThe <properties> element gives a list of properties for the subject of the current topic, for example whether a class is public or protected. Each property can include the type, value, and a description. To represent multiple values for a single type, create additional property elements and use only the <propvalue> element (and <propdesc> when needed) for each successive value. It can be placed inside <refbody> or <refbodydiv> elements.\n\nThe <proptypehd> element supports headings for the type column of a properties table.\nThe <proptypehd> element supports headings for the type column of a properties table.\nThe <propvaluehd> element supports headings for the value column of a properties table.\nThe <propdeschd> element supports headings for the description column of a properties table.\nThe <proptype> element describes the type of the property.\nThe <propvalue> element indicates one or more values for the current property type. Values can be placed in separate <property> elements if they need separate descriptions. The <proptype> element need not be repeated.\nThe <propdesc> element is used to provide a short description of the property type and its listed values.\nThe <example> element is a section that contains examples that illustrate or support the current topic. Use <example> to contain both sample code (or similar artifacts) and the discussion that illustrates the sample.\n\n\nTips\n=======\n* Preserve codeblock from the original content exactly as it is, including all whitespaces and indenting.\n* Do not loose content references (elements with conref, keyref or conkeyref attribute) such as <note conref=\"…\"/>.\n* Do not replace content references (elements with conref, keyref or conkeyref attribute) with the expanded content.\n* The <codeph> element represents a snippet of code within the main flow of text.\n* Do not place <properties> inside a section, they are sinblings to sections, pleace properties directly insisde refbody.\n* Make sure you close an element with the same tag name as its start tag.\n\nContent model information \n====================\n\nIn the models below \"?\" means optional, \",\" delimits sequence items, \"*\" means zero or more, \"|\" represents choice and \"(\" and \")\" are used for grouping. Always make sure that these content models are respected when you generate content.\n\n<reference> contains: \n<title>, <titlealts>?, (<abstract> | <shortdesc>)?, <prolog>?, <refbody>?, <related-links>?, (<concept> | <glossentry> | <glossgroup> | <reference> | <task> | <topic> | <troubleshooting>)*\n\n\n<refbody> contains: \n(<data> | <data-about> | <example> | <foreign> | <mathml> | <properties> | <refbodydiv> | <refsyn> | <section> | <simpletable> | <sort-as> | <svg-container> | <table> | <unknown>)*\n\n<refbodydiv> contains:\n(<data> | <data-about> | <example> | <foreign> | <mathml> | <properties> | <refbodydiv> | <refsyn> | <section> | <simpletable> | <sort-as> | <svg-container> | <table> | <unknown>)*\n\n<properties> contains:\n<prophead>?, <property>+\n\n<prophead> contains:\n<proptypehd>?, <propvaluehd>?, <propdeschd>?\n\n<property> contains:\n<proptype>?, <propvalue>?, <propdesc>?\n\n<refsyn> or <example> contain:\n(text data | <abbreviated-form> | <apiname> | <b> | <boolean> | <cite> | <cmdname> | <codeblock> | <codeph> | <data> | <data-about> | <div> | <dl> | <draft-comment> | <equation-block> | <equation-figure> | <equation-inline> | <fig> | <filepath> | <fn> | <foreign> | <hazardstatement> | <i> | <image> | <imagemap> | <indexterm> | <indextermref> | <keyword> | <line-through> | <lines> | <lq> | <markupname> | <mathml> | <menucascade> | <msgblock> | <msgnum> | <msgph> | <note> | <numcharref> | <object> | <ol> | <option> | <overline> | <p> | <parameterentity> | <parml> | <parmname> | <ph> | <pre> | <q> | <required-cleanup> | <screen> | <sectiondiv> | <simpletable> | <sl> | <sort-as> | <state> | <sub> | <sup> | <svg-container> | <synph> | <syntaxdiagram> | <systemoutput> | <table> | <term> | <text> | <textentity> | <title> | <tm> | <tt> | <u> | <uicontrol> | <ul> | <unknown> | <userinput> | <varname> | <wintitle> | <xmlatt> | <xmlelement> | <xmlnsname> | <xmlpi> | <xref>)*\n\nContent to be converted to reference follows\n============================\n\n",
        "parameters": {
            "temperature": 0,
            "function_refs": [
                {"ref": "validate_document_content"},
                {"ref": "resolve_dita_key_or_content_reference"},
                {"ref": "get_corresponding_dita_keyrefs"},
                {"ref": "get_related_content_from_project"}
            ]
        }
    },
    {
        "id": "com.oxygenxml.ai.positron.action.dita.formatTroubleshooting",
        "title": "Format as trobleshooting",
        "categoryId": "Analyze",
        "type": "replace-selection-with-fragment",
        "framework": "text/xml",
        "input-type": "markup",
        "description": "Format as DITA troubleshooting",
        "expand-params": [
            {
                "name": "contextInfo",
                "value": "${contextInfo}"
            }
        ],
        "context": "${contextInfo} \nYour task is to generate a DITA troubleshooting from all the content of given document that contains troubleshooting information but is encoded in a different format or it is provided as plain text or Markdown. \nIf the content contains information about multiple troubleshooting topics then split the initial content to reflect the content for each troubleshooting topic and then generate multiple troubleshooting topics inside a dita composite document.\n\nStart the response topic with the XML declaration and the troubleshooting or dita DOCTYPE declaration:\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE troubleshooting PUBLIC \"-//OASIS//DTD DITA Troubleshooting//EN\" \"troubleshooting.dtd\">\n<trobleshooting id=\"[generate an ID]\">\n...\n```\nor \n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE dita PUBLIC \"-//OASIS//DTD DITA Composite//EN\" \"ditabase.dtd\">\n<dita>\n...\n```\n\nGenerate id attribute for the troubleshooting root element and for additional troubleshooting elements if any.\nPreserve metadata information such as: altenative titles, navtitles, prolog information.\nPreserve profiling information defined by profiling attributes such as product, audience, platform, deliveryTarget, props, otherprops.\nInclude content references, elements that contain conref or conkeyref or keyref attributes, you may use the resolve_dita_key_or_content_reference function if you want to find the actual content they exand to.\n\nBelow you find information about DITA troubleshooting\n\nInformation about DITA troubleshooting\n=====================\nThe <troubleshooting> element is the top-level element for a troubleshooting topic. Troubleshooting topics begin with a description of a condition that the reader might want to correct, followed by one or more cause-remedy pairs. Each cause-remedy pair is a potential solution to the trouble described in the condition.\n\nThe <troublebody> element is a container for the main content of the troubleshooting topic.\n\nThe <condition> element describes a state that the troubleshooting topic is intended to remedy. This information helps the user decide whether a troubleshooting topic might contain an applicable remedy for a problem. This section should add to or clarify information that is in the tile or short description of the troubleshooting topic.\n\nThe <troubleSolution> element is a container element for cause and remedy information. The cause might be omitted if it is implicit or if the remedy is not associated with a cause. The remedy might be omitted if there is no known remedy for the cause.\n\nThe <cause> element describes a potential source of the problem that is described in the <condition> element, the topic <title> element, or the <shortdesc> element. This information should be brief; if it is not possible to make the information brief, this might be a sign that a full troubleshooting topic is needed\n\nThe <remedy> element contains steps that are a potential solution for the problem described in the <condition> element, the topic <title> element, or the <shortdesc> element. Typically, a <remedy> is preceded by a <cause>.\n\nUse the <responsibleParty> element to identify the party who is responsible for performing a remedy procedure.\n\nThe <steps> element provides the main content of a remedy. The remedy task is described as a series of steps that the user must follow to accomplish the remedy. At least one <step> element is required inside the <steps> element.\nLike the <steps> element, the <steps-unordered> element provides the main content of a task topic, but particularly for cases in which the order of steps might vary from one situation to another. At least one <step> element is required inside the <steps-unordered> element.\n\nThe <steps-informal> element allows authors to describe procedural remedy task information without placing each step in an individual container element, which is a requirement of the related <steps> and <steps-unordered> elements. For example, <steps-informal> might contain a paragraph that describes more than one step in a single sentence, or it might contain sentences that mix steps together with information about the steps.\n \nThe <stepsection> element provides expository text before a <step> element. Although the element is specialized from <li> and has the same content model as a list item, it is not intended to represent a step in a task.\n\nThe <step> element represents an action that a user must follow to accomplish a task. Each step in a task must contain a command \n\n<cmd> element which describes the particular action the user must do to accomplish the overall task. It is possible to place a <note> element before the command in order to notify the user of dangers or other important information about the step. The <step> element can also contain additional optional information about the step, such as sub-steps, a list of choices, or result information.\n\nThe <substeps> element allows you to break a step down into a series of separate actions, and should be used only if necessary. Try to describe the steps of a task in a single level of steps. If you need to use more than one level of <substep> nesting, you should probably rewrite the task to simplify it.\nA <substep> does NOT allow lists of choices or sub-steps within it, in order to prevent unlimited nesting of steps, so make sure you do not add <choices> or <substeps> inside it.\n\nThe <cmd> element specifies a command, which is a required element inside the <step> or <substep> element. It provides the active voice instruction to the user for completing the step, and should not be more than one sentence. If the step or substep needs additional explanation, place the explanation in an <info> element following the <cmd>. \n\nThe <choices> element contains a list of <choice> elements. It is used when the user will need to choose one of several actions while performing the steps of a task. \nEach <choice> element describes one way that the user could perform the current step, it does not contain <cmd>.\nThe <choicetable> element contains a series of optional choices available within a step of a task.\nThe <choptionhd> element provides a specific label for the list of options from which a user chooses in order to accomplish a step. \nThe <chdeschd> element provides a specific label for the list of descriptions of options from which a user chooses in order to accomplish a step. \nThe <choption> element describes an option in a choice table that a user could choose to accomplish a step of a task. In a user interface, for example, this might be the name of radio button.\nThe <chdesc> element is a description of an option from a choice table that a user chooses while performing a step to accomplish a task. It explains why the user would choose that option and might explain the result of the choice when it is not immediately obvious.\n\nThe <info> element occurs inside a <step> or <substep> element to provide additional information about that step or substep.\n\nThe <itemgroup> element can be used to sub-divide or organize elements that occur inside a list item, definition, or parameter definition.\n\nThe <stepxmp> element is used to illustrate a step of a task. The step example can be a couple of words, or an entire paragraph.\n\nThe <tutorialinfo> element contains additional information that is useful when the task is part of a tutorial.\n\nThe <stepresult> element provides information on the expected outcome of a step. If a user interface is being documented, the outcome could describe a dialog box opening or the appearance of a progress indicator. Step results are useful to assure a user that they are on track, but should not be used for every step as this quickly becomes tedious.\n\nThe <steptroubleshooting> element provides information that is designed to help remedy the situation when a step does not complete as expected. In particular, this element can be used to explain how users can recover when the results of a step do not match those listed in the <stepresult> element.\n\n\nTips\n=======\n* Do not generate a <note> or <codeblock> after </info>, generate them inside that <info> element, before the </info> closing tag.\n* <info> should not be placed inside a <choice> parent element.  \n* Preserve codeblock from the original content exactly as it is, including all whitespaces and indenting.\n* Do not place <codeblock> directly inside a step, wrap it in <info>.\n* Do not place <note> directly inside a step, if the note is after <cmd>, wrap it in <info>.\n* Do not loose content references (elements with conref, keyref or conkeyref attribute) such as <note conref=\"…\"/>.\n* Do not replace content references (elements with conref, keyref or conkeyref attribute) with the expanded content.\n* There is only one <steps> or <steps-informal> or <steps-unordered> allowed in a task body.\n* Do not nest <substeps>.\n* The <stepresult> element has parent elements <step> and <substep>, do not generate it inside <info>, generate it after the </info> closing tag.\n* The <codeph> element represents a snippet of code within the main flow of text.\n* Make sure you close an element with the same tag name as its start tag.\n\n\nContent model information \n====================\n\nIn the models below \"?\" means optional, \",\" delimits sequence items, \"*\" means zero or more, \"|\" represents choice and \"(\" and \")\" are used for grouping. Always make sure that these content models are respected when you generate content.\n\n<troubleshooting> contains: \n<title>, <titlealts>?, (<abstract> | <shortdesc>)?, <prolog>?, <troublebody>?, <related-links>?, (<concept> | <glossentry> | <glossgroup> | <reference> | <task> | <topic> | <troubleshooting>)*\n\n<troublebody> contains:\n(<condition>?, <troubleSolution>+)?\n\n<troubleSolution> contains:\n(<cause>*, <remedy>*)\n\n<remedy> contains:\n<title>?, <responsibleParty>?, (<steps> | <steps-informal> | <steps-unordered>)\n\n<steps> or <steps-unordered> contain:\n(<data> | <data-about> | <sort-as>)*, <stepsection>?, (<step>)+\n\n<step> contains:\n(<hazardstatement> | <note>)*, <cmd>, (<choices> | <choicetable> | <info> | <itemgroup> | <stepxmp> | <substeps> | <tutorialinfo>)*, <stepresult>?, <steptroubleshooting>?\n\n<substeps> contains:\n(<data> | <data-about> | <sort-as>)*, <substep>+\n\n<substep> contains:\n(<hazardstatement> | <note>)*, <cmd>, (<info> | <itemgroup> | <stepxmp> | <tutorialinfo>)*, <stepresult>?\n\n<choices> contains:\n(<data> | <data-about> | <sort-as>)*, <choice>+\n\nchoicetable> contains:\n<chhead>?, <chrow>+\n\n<chhead> contains:\n<choptionhd>, <chdeschd>\n\n<chrow> contains\n<choption>, <chdesc>\n\n<condition> or <cause> contains:\n<title>?, (<codeblock> | <data> | <data-about> | <div> | <dl> | <draft-comment> | <equation-block> | <equation-figure> | <fig> | <fn> | <foreign> | <hazardstatement> | <image> | <imagemap> | <indexterm> | <indextermref> | <lines> | <lq> | <mathml> | <msgblock> | <note> | <object> | <ol> | <p> | <parml> | <pre> | <required-cleanup> | <screen> | <sectiondiv> | <simpletable> | <sl> | <sort-as> | <svg-container> | <syntaxdiagram> | <table> | <ul> | <unknown>)*\n\n<responsibleParty> or <steps-informal> or <stepsection> or <choice> or <choptionhd> or <chdeschd> or <choption> or <chdesc> or <info> or <cmd> or <itemgroup> or <stepxmp> or <tutorialinfo> or <stepresult> or <steptroubleshooting> contain:\n(text data | <abbreviated-form> | <apiname> | <b> | <boolean> | <cite> | <cmdname> | <codeblock> | <codeph> | <data> | <data-about> | <div> | <dl> | <draft-comment> | <equation-block> | <equation-figure> | <equation-inline> | <fig> | <filepath> | <fn> | <foreign> | <hazardstatement> | <i> | <image> | <imagemap> | <indexterm> | <indextermref> | <keyword> | <line-through> | <lines> | <lq> | <markupname> | <mathml> | <menucascade> | <msgblock> | <msgnum> | <msgph> | <note> | <numcharref> | <object> | <ol> | <option> | <overline> | <p> | <parameterentity> | <parml> | <parmname> | <ph> | <pre> | <q> | <required-cleanup> | <screen> | <sectiondiv> | <simpletable> | <sl> | <sort-as> | <state> | <sub> | <sup> | <svg-container> | <synph> | <syntaxdiagram> | <systemoutput> | <table> | <term> | <text> | <textentity> | <tm> | <tt> | <u> | <uicontrol> | <ul> | <unknown> | <userinput> | <varname> | <wintitle> | <xmlatt> | <xmlelement> | <xmlnsname> | <xmlpi> | <xref>)*\n\n\nContent to be converted to troubleshooting follows\n============================\n\n",
        "parameters": {
            "temperature": 0,
            "function_refs": [
                {"ref": "validate_document_content"},
                {"ref": "resolve_dita_key_or_content_reference"},
                {"ref": "get_corresponding_dita_keyrefs"},
                {"ref": "get_related_content_from_project"}
            ]
        }
    },
    {
        "id": "com.oxygenxml.ai.positron.action.dita.formatGlossary",
        "title": "Format as glossary entry or group",
        "categoryId": "Analyze",
        "type": "replace-selection-with-fragment",
        "framework": "text/xml",
        "input-type": "markup",
        "description": "Format as DITA glossary entry or glossary group",
        "expand-params": [
            {
                "name": "contextInfo",
                "value": "${contextInfo}"
            }
        ],
        "context": "${contextInfo} \nYour will generate a DITA glossary entry from all the content of given document that contains glossary information but is encoded in a different format or it is provided as plain text or Markdown. \nIf the content contains consistent information about multiple glossary entries then split the initial content to reflect the content for each glossaey entry and then generate multiple glossary entries inside a glossary group (glossgroup) document.\n\nStart the response with the XML declaration and the glossentry or glossgroup DOCTYPE declaration:\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE glossentry PUBLIC \"-//OASIS//DTD DITA Glossary Entry//EN\" \"glossaryentry.dtd\">\n```\nor \n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE glossgroup PUBLIC \"-//OASIS//DTD DITA Glossary Group//EN\" \"glossgroup.dtd\">\n```\n\nGenerate id attribute for the glossgroup or glossentry root element and for additional glossentry if any.\nPreserve metadata information such as: altenative titles, navtitles, prolog information.\nPreserve profiling information defined by profiling attributes such as product, audience, platform, deliveryTarget, props, otherprops.\nInclude content references, elements that contain conref or conkeyref or keyref attributes, you may use the resolve_dita_key_or_content_reference function if you want to find the actual content they exand to.\n\nBelow you find information about DITA glossary entry and glossary group.\n\nInformation about DITA glossentry and glossgroup\n========================\n\n  The <glossentry> element defines a single sense of a glossary term. Glossary entries for different term senses can be reused independently of one another.\n\n  The <glossterm> element specifies the preferred term that is associated with a definition of a sense. If the same term has multiple senses, create a separate <glossentry> topic for each sense.\n\n    The <glossdef> element specifies the definition of one sense of a term. If a term has multiple senses, create a separate <glossentry> topic to define each sense.\n\n    The <glossAbbreviation> element provides an abbreviated form of the term that is contained in a <glossterm> element.\n\n    The <glossAcronym> element defines an acronym for the term that is defined in the <glossterm> element.\n\n    The <glossAlt> element contains a variant term for the preferred term. The variant should have the same meaning as the term in the <glossterm> element; the variant is simply another way to refer to the same term. There might be many ways to refer to a term; each variant is placed in its own <glossAlt> element. The <glossUsage> element can be used within <glossAlt> to indicate when use of the alternate term is appropriate.\n\n    The <glossAlternateFor> element indicates when a variant term has a relationship to another variant term in addition to the preferred term.\n\n    The <glossBody> element is used to provide details about a glossary term (such as part of speech or additional forms of the term).\n\n    The <glossPartOfSpeech> element identifies the part of speech for the preferred and alternate terms. Alternate terms must have the same part of speech as the preferred term, because all terms in the <glossentry> topic designate the same subject.\n\n    The <glossProperty> element is a specialization of the <data> element. You can use it to specify additional details about the preferred term or its subject, for example, the gender of a noun.\n\n    The <glossScopeNote> element contains a clarification of the subject that is designated by the <glossterm>, such as examples of included or excluded companies or products. For instance, a scope note for \"Linux\" might explain that the term doe not apply to UNIX products; it might give examples of Linux products that are included as well as UNIX products that are excluded.\n\n    The <glossShortForm> element provides a shorter alternative to the primary term that is specified in the <glossterm> element.\n\n    The <glossStatus> element identifies the usage status of a preferred or alternate term. If the status isn't specified, the <glossterm> provides a preferred term and an alternate term provides an allowed term.\n\n    The <glossSurfaceForm> element specifies an unambiguous presentation of the <glossterm> that might combine multiple forms. The surface form is suitable to introduce the term in new contexts.\n\n    The <glossSymbol> element identifies a standard image that is associated with the subject of the <glossterm> element.\n\n    The <glossSynonym> element provides a term that is a synonym of the primary value in the <glossterm> element.\n\n    The <glossUsage> element provides information about the correct use of a term, such as where or how it can be used.\n\n    The <abbreviated-form> element represents a reference to a term that might appear in an abbreviated form (often an acronym). The long and short forms of the term are generally defined in a <glossentry> topic. Processors display the referenced term when rendering an <abbreviated-form> element.\n\n    The <glossref> element is a convenience element in maps for creating a reference to a glossary topic. It has a required @keys attribute, which forces the author to create a key by which inline terms can reference their definition. For example, when <glossentry> topics are used to define acronyms, this reminds authors to create a key which <abbreviated-form> elements can use to reference the short and expanded versions of that acronym.\n\n   The <glossgroup> is a specialized topic that can contain multiple <glossentry> topics within a single document.\n\nTips\n=======\n* Do not loose content references (elements with conref, keyref or conkeyref attribute) such as <note conref=\"…\"/>.\n* Do not replace content references (elements with conref, keyref or conkeyref attribute) with the expanded content.\n* The <codeph> element represents a snippet of code within the main flow of text.\n* Make sure you close an element with the same tag name as its start tag.\n\n\nContent model information \n====================\n\nIn the models below \"?\" means optional, \",\" delimits sequence items, \"*\" means zero or more, \"|\" represents choice and \"(\" and \")\" are used for grouping. Always make sure that these content models are respected when you generate content.\n\n<glossgroup> contains:\n<title>, <prolog>?, (<glossentry> | <glossgroup>)*\n\n<glossentry> contains:\n<glossterm>, <glossdef>?, <prolog>?, <glossBody>?, <related-links>?\n\n<glossBody> contains:\n<glossPartOfSpeech>?, <glossStatus>?, <glossProperty>*, <glossSurfaceForm>?, <glossUsage>?, <glossScopeNote>?, <glossSymbol>*, (<hazardstatement> | <note>)*, <glossAlt>*\n\n<glossAlt> contains:\n(<glossAbbreviation> | <glossAcronym> | <glossShortForm> | <glossSynonym>)?, <glossStatus>?, <glossProperty>*, <glossUsage>?, (<hazardstatement> | <note>)*, <glossAlternateFor>*\n\n<glossterm> contains:\n(text data | <abbreviated-form> | <apiname> | <b> | <boolean> | <cite> | <cmdname> | <codeph> | <data> | <data-about> | <draft-comment> | <equation-inline> | <filepath> | <foreign> | <i> | <image> | <keyword> | <line-through> | <markupname> | <mathml> | <menucascade> | <msgnum> | <msgph> | <numcharref> | <option> | <overline> | <parameterentity> | <parmname> | <ph> | <q> | <required-cleanup> | <sort-as> | <state> | <sub> | <sup> | <svg-container> | <synph> | <systemoutput> | <term> | <text> | <textentity> | <tm> | <tt> | <u> | <uicontrol> | <unknown> | <userinput> | <varname> | <wintitle> | <xmlatt> | <xmlelement> | <xmlnsname> | <xmlpi>)*\n\n<glossdef> or <glossUsage> or <glossScopeNote> contain:\n(text data | <abbreviated-form> | <apiname> | <b> | <boolean> | <cite> | <cmdname> | <codeblock> | <codeph> | <data> | <data-about> | <div> | <dl> | <draft-comment> | <equation-block> | <equation-figure> | <equation-inline> | <fig> | <filepath> | <fn> | <foreign> | <hazardstatement> | <i> | <image> | <imagemap> | <indexterm> | <indextermref> | <keyword> | <line-through> | <lines> | <lq> | <markupname> | <mathml> | <menucascade> | <msgblock> | <msgnum> | <msgph> | <note> | <numcharref> | <object> | <ol> | <option> | <overline> | <p> | <parameterentity> | <parml> | <parmname> | <ph> | <pre> | <q> | <required-cleanup> | <screen> | <shortdesc> | <simpletable> | <sl> | <sort-as> | <state> | <sub> | <sup> | <svg-container> | <synph> | <syntaxdiagram> | <systemoutput> | <table> | <term> | <text> | <textentity> | <tm> | <tt> | <u> | <uicontrol> | <ul> | <unknown> | <userinput> | <varname> | <wintitle> | <xmlatt> | <xmlelement> | <xmlnsname> | <xmlpi> | <xref>)*\n\n<glossProperty> contains:\n(text data | <abbreviated-form> | <apiname> | <b> | <boolean> | <cite> | <cmdname> | <codeph> | <data> | <data-about> | <draft-comment> | <equation-inline> | <filepath> | <foreign> | <i> | <image> | <keyword> | <line-through> | <markupname> | <mathml> | <menucascade> | <msgnum> | <msgph> | <numcharref> | <object> | <option> | <overline> | <parameterentity> | <parmname> | <ph> | <q> | <required-cleanup> | <sort-as> | <state> | <sub> | <sup> | <svg-container> | <synph> | <systemoutput> | <term> | <text> | <textentity> | <title> | <tm> | <tt> | <u> | <uicontrol> | <unknown> | <userinput> | <varname> | <wintitle> | <xmlatt> | <xmlelement> | <xmlnsname> | <xmlpi> | <xref>)*\n\n<glossSurfaceForm> or <glossAbbreviation> or <glossAcronym> or <glossShortForm>  or <glossSynonym>  contain:\n(text data | <abbreviated-form> | <apiname> | <cmdname> | <keyword> | <markupname> | <msgnum> | <numcharref> | <option> | <parameterentity> | <parmname> | <term> | <text> | <textentity> | <tm> | <varname> | <wintitle> | <xmlatt> | <xmlelement> | <xmlnsname> | <xmlpi>)*\n\n<glossSymbol> contains\n<alt>?, <longdescref>?\n\nEmpty elements:\n<glossPartOfSpeech/>, <glossStatus/>, <glossAlternateFor/>\n\nExample glossentry document\n==========\n<glossentry id=\"usbfd\">\n  <glossterm>USB flash drive</glossterm>\n  <glossdef>A small portable drive.</glossdef>\n  <glossBody>\n    <glossPartOfSpeech value=\"noun\"/>\n    <glossUsage>Do not provide in upper case (as in \"USB Flash\nDrive\") because that suggests a trademark.</glossUsage>\n    <glossAlt>\n      <glossAcronym>UFD</glossAcronym>\n      <glossUsage>Explain the acronym on first occurrence.</glossUsage>\n    </glossAlt>\n    <glossAlt id=\"memoryStick\">\n      <glossSynonym>memory stick</glossSynonym>\n      <glossUsage>This is a colloquial term.</glossUsage>\n    </glossAlt>\n    <glossAlt>\n      <glossAbbreviation>stick</glossAbbreviation>\n      <glossStatus value=\"prohibited\"/>\n      <glossUsage>This is too colloquial.</glossUsage>\n      <glossAlternateFor href=\"#usbfd/memoryStick\"/>\n    </glossAlt>\n    <glossAlt>\n      <glossAbbreviation>flash</glossAbbreviation>\n      <glossStatus value=\"prohibited\"/>\n      <glossUsage>This short form is ambiguous.</glossUsage>\n    </glossAlt>\n  </glossBody>\n</glossentry>\n\n\nContent to be converted to glossay entry ot group follows\n============================\n\n",
        "parameters": {
            "temperature": 0,
            "function_refs": [
                {"ref": "validate_document_content"},
                {"ref": "resolve_dita_key_or_content_reference"},
                {"ref": "get_corresponding_dita_keyrefs"},
                {"ref": "get_related_content_from_project"}
            ]
        }
    },
    {
        "id": "",
        "title": "",
        "short-description": "",
        "description": "",
        "categoryId": "",
        "type": "create-new-document",
        "context": ""
    }
]